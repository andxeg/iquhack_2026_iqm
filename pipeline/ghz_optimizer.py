# -*- coding: utf-8 -*-
"""GHZ_Optimizer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c_dREMcEa1oQZoL_Uvm7eAiyTU8rAtQr
"""

from qiskit import QuantumCircuit, transpile
import numpy as np
from matplotlib import pyplot as plt
import networkx as nx
from collections import deque
import json

# Rank qubits and gates
def rank_qubits():
    """Rank qubits by readout error."""
    quality = []
    for qb in READOUT_P10.keys():
        total_error = READOUT_P10[qb] + READOUT_P01[qb]
        quality.append((qb, total_error))
    quality.sort(key=lambda x: x[1])
    return quality

def rank_gates():
    """Rank gates by fidelity."""
    gates = [(pair, fid) for pair, fid in CZ_FIDELITY.items()]
    gates.sort(key=lambda x: x[1], reverse=True)
    return gates

# Build weighted graph (FIXED!)
def build_weighted_graph(backend, max_qubit_error, min_gate_fidelity):
    """
    Build graph with:
    - Nodes: Only good qubits (error < max_qubit_error)
    - Edges: Only good gates (fidelity >= min_gate_fidelity)
    - Node weight: qubit quality (1 - error)
    - Edge weight: gate fidelity
    """
    G = nx.Graph()

    # Add nodes (only good qubits)
    good_qubits = []
    bad_qubits = []

    for qb in READOUT_P10.keys():
        idx = int(qb[2:]) - 1  # QB1 -> 0
        error = READOUT_P10[qb] + READOUT_P01[qb]

        if error < max_qubit_error:
            G.add_node(idx,
                       name=qb,
                       error=error,
                       quality=1-error,
                       p10=READOUT_P10[qb],
                       p01=READOUT_P01[qb])
            good_qubits.append(qb)
        else:
            bad_qubits.append((qb, error))

    print(f"Nodes (good qubits): {G.number_of_nodes()}")
    print(f"Excluded qubits: {[q for q,e in bad_qubits]}")

    # Add edges (only good gates between good qubits)
    good_edges = 0
    bad_edges = 0
    missing_edges = 0

    for edge in backend.coupling_map:
        idx1, idx2 = edge
        qb1 = f"QB{idx1+1}"
        qb2 = f"QB{idx2+1}"

        # Skip if either qubit is bad
        if idx1 not in G.nodes or idx2 not in G.nodes:
            continue

        # Get CZ fidelity
        fidelity = get_cz_fidelity(qb1, qb2)

        if fidelity is None:
            missing_edges += 1
            # Use default if no calibration data
            fidelity = 0.98

        # Only add edge if fidelity is good enough
        if fidelity >= min_gate_fidelity:
            if not G.has_edge(idx1, idx2):  # Avoid duplicates
                G.add_edge(idx1, idx2, fidelity=fidelity)
                good_edges += 1
        else:
            bad_edges += 1

    print(f"\nEdges (good gates): {G.number_of_edges()}")
    print(f"Excluded gates (fidelity < {min_gate_fidelity}): {bad_edges}")
    if missing_edges > 0:
        print(f"Gates with missing calibration data: {missing_edges}")

    return G

# Find optimal path (DFS)

def find_optimal_path(G, n_qubits):
    """
    Find optimal connected path maximizing:
    - Sum of qubit qualities (node weights)
    - Sum of gate fidelities (edge weights)

    Path score = Σ(1 - qubit_error) + 2 * Σ(gate_fidelity)

    Edge weights are doubled because GHZ needs N-1 CX gates!
    """

    if G.number_of_nodes() < n_qubits:
        print(f"❌ Not enough good qubits: {G.number_of_nodes()} < {n_qubits}")
        return None

    def path_score(path):
        """Calculate total score for a path."""
        if len(path) < 2:
            return 0

        # Node score (qubit quality)
        node_score = sum(G.nodes[n]['quality'] for n in path)

        # Edge score (gate fidelity) - WEIGHTED 2x!
        edge_score = 0
        for i in range(len(path) - 1):
            if G.has_edge(path[i], path[i+1]):
                edge_score += G.edges[path[i], path[i+1]]['fidelity']
            else:
                return -1000  # Invalid path!

        return node_score + 2 * edge_score

    def dfs_best_path(start, n):
        """DFS to find best scoring path."""
        best_path = [start]
        best_score = 0

        stack = [(start, [start])]

        while stack:
            curr, path = stack.pop()

            if len(path) == n:
                score = path_score(path)
                if score > best_score:
                    best_score = score
                    best_path = path.copy()
                continue

            if len(path) > len(best_path):
                score = path_score(path)
                if score > best_score:
                    best_score = score
                    best_path = path.copy()

            # Get neighbors sorted by combined score
            neighbors = []
            for nb in G.neighbors(curr):
                if nb not in path:
                    nb_quality = G.nodes[nb]['quality']
                    edge_fidelity = G.edges[curr, nb]['fidelity']
                    combined = nb_quality + edge_fidelity
                    neighbors.append((nb, combined))

            neighbors.sort(key=lambda x: x[1], reverse=True)

            for nb, _ in neighbors[:5]:  # Explore top 5
                stack.append((nb, path + [nb]))

        return best_path, best_score

    # Try starting from best qubits
    sorted_nodes = sorted(G.nodes(), key=lambda n: G.nodes[n]['quality'], reverse=True)

    overall_best = []
    overall_best_score = -1

    print(f"Searching for {n_qubits}-qubit path...")

    for i, start in enumerate(sorted_nodes[:15]):
        path, score = dfs_best_path(start, n_qubits)
        if len(path) >= n_qubits and score > overall_best_score:
            overall_best = path[:n_qubits]
            overall_best_score = score
            print(f"   Found path from QB{start+1}: score = {score:.4f}")

    if len(overall_best) < n_qubits:
        print(f"\n⚠️ Could only find path of {len(overall_best)} qubits")
        return overall_best if overall_best else None

    return overall_best

# Mitigation functions
from iqm.iqm_client import CircuitCompilationOptions
from iqm.iqm_client.models import DDMode, STANDARD_DD_STRATEGY, HeraldingMode

def mitigate_zz(counts, n, p10, p01):
    """Mitigate ZZ expectation value."""
    total = sum(counts.values())
    all_0 = '0' * n
    all_1 = '1' * n

    p_00_00 = np.prod(1 - p10)
    p_11_11 = np.prod(1 - p01)
    p_00_11 = np.prod(p01)
    p_11_00 = np.prod(p10)

    A = np.array([[p_00_00, p_00_11], [p_11_00, p_11_11]])
    p_meas = np.array([counts.get(all_0, 0)/total, counts.get(all_1, 0)/total])

    try:
        A_inv = np.linalg.inv(A)
        p_true = np.clip(A_inv @ p_meas, 0, 1)
        if p_true.sum() > 1:
            p_true /= p_true.sum()
        return 2 * (p_true[0] + p_true[1]) - 1, p_true[0], p_true[1]
    except:
        p00 = counts.get(all_0, 0) / total
        p11 = counts.get(all_1, 0) / total
        return 2*(p00+p11)-1, p00, p11

def mitigate_xx(counts, n, p10, p01):
    """Mitigate XX expectation value."""
    total = sum(counts.values())
    p_flip = (p10 + p01) / 2
    parity_factor = np.prod(1 - 2 * p_flip)

    xx_raw = sum((1 if s.count('1')%2==0 else -1) * c/total for s,c in counts.items())

    if abs(parity_factor) > 0.01:
        xx_mit = np.clip(xx_raw / parity_factor, -1, 1)
    else:
        xx_mit = xx_raw

    return xx_mit, xx_raw

def create_ghz(n, basis='Z'):
    qc = QuantumCircuit(n, n)
    qc.h(0)
    for i in range(n - 1):
        qc.cx(i, i + 1)
    if basis == 'X':
        for i in range(n):
            qc.h(i)
    qc.measure_all()
    return qc
    
def set_readout_calibration(p10: dict, p01: dict, czf: dict):
    global READOUT_P10, READOUT_P01, CZ_FIDELITY
    READOUT_P10 = p10
    READOUT_P01 = p01
    CZ_FIDELITY = czf
    
def get_cz_fidelity(qb1, qb2):
    """Get CZ fidelity between two qubits (order-independent)."""
    key1 = f"{qb1}__{qb2}"
    key2 = f"{qb2}__{qb1}"
    return CZ_FIDELITY.get(key1, CZ_FIDELITY.get(key2, None))
    
READOUT_P10 = None
READOUT_P01 = None
CZ_FIDELITY = None